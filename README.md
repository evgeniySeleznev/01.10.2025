# File Downloader Service

Веб-сервис на Go для скачивания файлов по списку URL с поддержкой graceful shutdown и восстановления состояния после перезапуска.

## Требования

- **Go**: версия 1.24 или выше
- **Зависимости**: см. `go.mod`

## Архитектура

Проект построен по принципам Clean Architecture с четким разделением на слои:

```
├── cmd/                    # Точка входа приложения
│   └── main.go
├── internal/
│   ├── entities/          # Бизнес-сущности
│   │   ├── task.go
│   │   └── task_test.go
│   ├── interfaces/        # Интерфейсы для слоев
│   │   ├── repository.go
│   │   ├── usecase.go
│   │   └── http.go
│   ├── usecases/          # Бизнес-логика
│   │   ├── task.go
│   │   ├── download.go
│   │   └── task_test.go
│   ├── adapters/          # Адаптеры для внешних систем
│   │   ├── repository/
│   │   │   ├── inmemory.go
│   │   │   └── filebased.go
│   │   └── http/
│   │       ├── handlers.go
│   │       └── routes.go
│   └── infrastructure/    # Инфраструктурные компоненты
│       └── worker_pool.go
├── go.mod
└── README.md
```

### Слои архитектуры

1. **Entities** - Бизнес-сущности (Task, File, TaskStatus)
2. **Use Cases** - Бизнес-логика приложения
3. **Interface Adapters** - HTTP handlers, repositories
4. **Infrastructure** - Worker pool, файловая система

## Используемые паттерны

### 1. Clean Architecture
- Разделение на слои с четкими зависимостями
- Инверсия зависимостей через интерфейсы
- Изоляция бизнес-логики от внешних деталей

### 2. Repository Pattern
- Абстракция доступа к данным через интерфейсы
- Реализации: in-memory и file-based
- Единообразный API для работы с задачами

### 3. Worker Pool Pattern
- Ограничение количества параллельных скачиваний
- Эффективное управление ресурсами
- Graceful shutdown с завершением текущих задач

### 4. Dependency Injection
- Внедрение зависимостей через интерфейсы
- Легкое тестирование и замена компонентов
- Слабая связанность между слоями

### 5. Graceful Shutdown
- Корректное завершение работы сервера
- Сохранение состояния в файл
- Остановка worker pool с завершением задач

## Функциональность

### Основные возможности
- Создание задач скачивания по списку URL
- Получение статуса задач (новая, в обработке, завершена, завершена с ошибкой)
- Параллельное скачивание файлов (настраиваемое количество воркеров)
- Сохранение состояния в JSON-файл
- Восстановление состояния после перезапуска

### Статусы задач
- `new` - новая задача
- `processing` - в процессе скачивания
- `completed` - успешно завершена
- `failed` - завершена с ошибкой

## Запуск

```bash
# Установка зависимостей
go mod tidy

# Запуск сервиса
go run cmd/main.go
```

Сервис будет доступен по адресу `http://localhost:8080`

## API Endpoints

### Создание задачи
```bash
curl -X POST http://localhost:8080/tasks \
  -H "Content-Type: application/json" \
  -d '{
    "urls": [
      "https://example.com/file1.jpg",
      "https://example.com/file2.pdf"
    ]
  }'
```

### Получение всех задач
```bash
curl http://localhost:8080/tasks
```

### Получение задачи по ID
```bash
curl http://localhost:8080/tasks/{task-id}
```

### Получение статуса задачи
```bash
curl http://localhost:8080/tasks/{task-id}/status
```

### Health check
```bash
curl http://localhost:8080/health
```

## Примеры использования

### 1. Создание задачи скачивания

```bash
curl -X POST http://localhost:8080/tasks \
  -H "Content-Type: application/json" \
  -d '{
    "urls": [
      "https://httpbin.org/image/jpeg",
      "https://httpbin.org/image/png",
      "https://httpbin.org/image/svg"
    ]
  }'
```

Ответ:
```json
{
  "id": "123e4567-e89b-12d3-a456-426614174000",
  "urls": [
    "https://httpbin.org/image/jpeg",
    "https://httpbin.org/image/png", 
    "https://httpbin.org/image/svg"
  ],
  "status": "new",
  "created_at": "2023-12-07T10:00:00Z",
  "updated_at": "2023-12-07T10:00:00Z",
  "files": [
    {
      "url": "https://httpbin.org/image/jpeg",
      "status": "pending"
    },
    {
      "url": "https://httpbin.org/image/png",
      "status": "pending"
    },
    {
      "url": "https://httpbin.org/image/svg", 
      "status": "pending"
    }
  ]
}
```

### 2. Проверка статуса задачи

```bash
curl http://localhost:8080/tasks/123e4567-e89b-12d3-a456-426614174000/status
```

Ответ:
```json
{
  "id": "123e4567-e89b-12d3-a456-426614174000",
  "status": "processing",
  "progress": 66,
  "created_at": "2023-12-07T10:00:00Z",
  "updated_at": "2023-12-07T10:02:30Z",
  "files": [
    {
      "url": "https://httpbin.org/image/jpeg",
      "path": "./downloads/123e4567-e89b-12d3-a456-426614174000/image.jpeg",
      "size": 12345,
      "status": "completed"
    },
    {
      "url": "https://httpbin.org/image/png",
      "path": "./downloads/123e4567-e89b-12d3-a456-426614174000/image.png",
      "size": 23456,
      "status": "completed"
    },
    {
      "url": "https://httpbin.org/image/svg",
      "status": "downloading"
    }
  ]
}
```

## Graceful Shutdown

Сервис поддерживает корректное завершение работы:

1. **Получение сигнала остановки** (SIGINT, SIGTERM)
2. **Остановка приема новых задач** - контекст отменяется
3. **Завершение текущих скачиваний** - worker pool останавливается
4. **Сохранение состояния** - все задачи сохраняются в файл
5. **Остановка HTTP сервера** - с таймаутом 5 секунд

### Восстановление после перезапуска

При запуске сервис:
1. Загружает сохраненные задачи из файла `./data/tasks.json`
2. Восстанавливает задачи со статусом `new` или `processing`
3. Продолжает обработку незавершенных задач

## Тестирование функциональности

### Проверка основных сценариев

#### 1. Создание задачи
```bash
# PowerShell
$body = @{
    urls = @("https://httpbin.org/image/jpeg", "https://httpbin.org/image/png")
} | ConvertTo-Json

Invoke-RestMethod -Uri "http://localhost:8080/tasks" -Method POST -ContentType "application/json" -Body $body
```

#### 2. Проверка статуса задачи
```bash
# PowerShell
Invoke-RestMethod -Uri "http://localhost:8080/tasks/{task-id}/status" -Method GET
```

#### 3. Тестирование Graceful Shutdown
1. Запустить сервис: `go run cmd/main.go`
2. Создать несколько задач
3. Отправить сигнал остановки (Ctrl+C)
4. Проверить сохранение в `./data/tasks.json`
5. Перезапустить сервис
6. Убедиться, что незавершенные задачи продолжили обработку

#### 4. Проверка восстановления после перезапуска
```bash
# Создать задачу
curl -X POST http://localhost:8080/tasks -H "Content-Type: application/json" -d '{"urls": ["https://httpbin.org/image/jpeg"]}'

# Остановить сервис (Ctrl+C)

# Перезапустить сервис
go run cmd/main.go

# Проверить, что задача продолжила обработку
curl http://localhost:8080/tasks/{task-id}/status
```

### Стресс-тестирование

#### Одновременные запросы
```bash
# Создать несколько задач одновременно
for i in {1..10}; do
  curl -X POST http://localhost:8080/tasks -H "Content-Type: application/json" -d '{"urls": ["https://httpbin.org/image/jpeg"]}' &
done
wait
```

#### Большие списки URL
```bash
# Создать задачу с большим количеством файлов
curl -X POST http://localhost:8080/tasks -H "Content-Type: application/json" -d '{
  "urls": [
    "https://httpbin.org/image/jpeg",
    "https://httpbin.org/image/png", 
    "https://httpbin.org/image/svg",
    "https://httpbin.org/image/webp"
  ]
}'
```

## Unit тестирование

```bash
# Запуск всех тестов
go test ./...

# Запуск тестов с покрытием
go test -cover ./...

# Запуск тестов конкретного пакета
go test ./internal/usecases

# Запуск тестов с детальным выводом
go test -v ./...

# Запуск тестов с профилированием
go test -cpuprofile=cpu.prof -memprofile=mem.prof ./...
```

### Покрытие тестами
```bash
# Генерация отчета о покрытии
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out -o coverage.html

# Просмотр покрытия в терминале
go tool cover -func=coverage.out
```

## Конфигурация

Основные параметры можно настроить в `cmd/main.go`:

- **Количество воркеров**: по умолчанию 3
- **Порт сервера**: по умолчанию 8080
- **Путь к файлу состояния**: `./data/tasks.json`
- **Директория скачивания**: `./downloads`

## Структура данных

### Файл состояния (tasks.json)
```json
{
  "task-id-1": {
    "id": "task-id-1",
    "urls": ["https://example.com/file1.jpg"],
    "status": "completed",
    "created_at": "2023-12-07T10:00:00Z",
    "updated_at": "2023-12-07T10:01:00Z",
    "files": [
      {
        "url": "https://example.com/file1.jpg",
        "path": "./downloads/task-id-1/file1.jpg",
        "size": 12345,
        "status": "completed"
      }
    ]
  }
}
```

### Директория скачивания
```
downloads/
├── task-id-1/
│   ├── file1.jpg
│   └── file2.pdf
└── task-id-2/
    └── image.png
```

## Обработка ошибок

- **HTTP ошибки**: логируются, задача помечается как failed
- **Ошибки сети**: повторные попытки не реализованы (можно добавить)
- **Ошибки файловой системы**: логируются, задача помечается как failed
- **Ошибки валидации**: возвращаются клиенту с соответствующим HTTP кодом

## Производительность

- **Worker Pool**: ограничивает нагрузку на систему
- **In-memory хранилище**: быстрый доступ к данным
- **File-based persistence**: надежное сохранение состояния
- **Graceful shutdown**: корректное завершение без потери данных

## Безопасность

- **Валидация URL**: базовая проверка на пустые значения
- **Изоляция файлов**: каждый таск скачивается в отдельную директорию
- **Ограничение размера**: можно добавить лимиты на размер файлов

## Возможные улучшения

1. **Повторные попытки**: retry механизм для неудачных скачиваний
2. **Метрики**: Prometheus метрики для мониторинга
3. **Логирование**: структурированные логи с уровнями
4. **Конфигурация**: файл конфигурации вместо хардкода
5. **Аутентификация**: JWT токены для защиты API
6. **Rate limiting**: ограничение количества запросов
7. **Сжатие**: gzip для HTTP ответов
8. **Кэширование**: кэш для повторных запросов

## Важные технические детали

### Соответствие техническому заданию

Данный сервис полностью соответствует всем требованиям технического задания:

1. **Основной функционал:**
   - ✅ Прием задач со списком URL для скачивания
   - ✅ Параллельное скачивание файлов в отдельные папки
   - ✅ Получение статуса задач через API

2. **Критическое требование - Graceful Shutdown:**
   - ✅ Корректная обработка сигналов остановки (SIGINT, SIGTERM)
   - ✅ Сохранение состояния всех задач в файл `./data/tasks.json`
   - ✅ Восстановление незавершенных задач при перезапуске
   - ✅ Продолжение приема новых задач до получения сигнала остановки
   - ✅ Graceful завершение текущих скачиваний

3. **Технические ограничения:**
   - ✅ Без внешней инфраструктуры (Docker, БД, nginx)
   - ✅ Использование только стандартной библиотеки Go
   - ✅ Файловое хранилище для персистентности

### Особенности реализации

#### Обработка перезапуска сервиса
При запуске сервис автоматически:
1. Загружает сохраненные задачи из `./data/tasks.json`
2. Восстанавливает задачи со статусом `new` или `processing`
3. Продолжает обработку незавершенных задач
4. Создает необходимые директории для скачивания

#### Graceful Shutdown процесс
При получении сигнала остановки:
1. **Отмена контекста** - прекращение приема новых задач в worker pool
2. **Остановка worker pool** - завершение текущих скачиваний
3. **Сохранение состояния** - запись всех задач в файл
4. **Остановка HTTP сервера** - с таймаутом 5 секунд

#### Безопасность данных
- Все операции с файлами защищены мьютексами
- Атомарное сохранение состояния
- Изоляция файлов по задачам
- Обработка ошибок файловой системы

### Ограничения и рекомендации

#### Текущие ограничения:
1. **Нет повторных попыток** - неудачные скачивания помечаются как failed
2. **Нет ограничения размера файлов** - можно добавить лимиты
3. **Нет аутентификации** - API открыт для всех
4. **Нет rate limiting** - можно добавить ограничения запросов

#### Рекомендации для продакшена:
1. **Добавить retry механизм** для неудачных скачиваний
2. **Настроить логирование** с уровнями (debug, info, warn, error)
3. **Добавить метрики** для мониторинга (Prometheus)
4. **Настроить конфигурацию** через переменные окружения
5. **Добавить health checks** для Kubernetes/Docker

### Производительность

#### Оптимизации:
- **Worker Pool** ограничивает количество параллельных скачиваний (по умолчанию 3)
- **In-memory репозиторий** для быстрого доступа к данным
- **File-based persistence** для надежного сохранения
- **Контекстная отмена** для быстрого завершения операций

#### Масштабируемость:
- Количество воркеров настраивается в `cmd/main.go`
- Буфер очереди задач: 100 задач
- Таймауты: HTTP клиент 30 сек, сервер shutdown 5 сек

## Разработка

### Структура проекта
Проект следует стандартной структуре Go приложений с разделением на пакеты по функциональности.

### Тестирование
- Unit тесты для бизнес-логики
- Интеграционные тесты для HTTP handlers
- Моки для внешних зависимостей

### Линтинг
```bash
# Проверка кода
golangci-lint run

# Форматирование
go fmt ./...

# Проверка импортов
goimports -w .
```

## Лицензия

MIT License